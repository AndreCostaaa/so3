diff -Naru ../so3.base/Dockerfile ./Dockerfile
--- ../so3.base/Dockerfile	2023-04-02 13:19:24.698875432 +0200
+++ ./Dockerfile	2023-04-02 13:18:33.832210718 +0200
@@ -9,14 +9,16 @@
     bridge-utils iptables dnsmasq \
     util-linux qemu-system-arm
 
-RUN cd /; \
-    wget https://github.com/smartobjectoriented/so3/archive/refs/heads/master.zip; \
-    unzip master.zip; mv so3-master so3
+COPY        / /so3
 
 WORKDIR so3
 
 RUN     find / -name thumb | xargs rm -r; \
-        patch -s -p0 < ci/so3_ci.patch; \
+        cd filesystem; patch -s -p0 < ../ci/filesystem.patch; cd ..; \
+        patch -p0 st ci/st.patch; \
+        patch -p0 deploy.sh ci/deploy.sh.patch; \
+        cd rootfs; patch -s -p0 < ../ci/rootfs.patch; cd ..; \
+        cd usr; patch -s -p0 < ../ci/usr.patch; cd ..; \
         cd u-boot; make vexpress_defconfig; make -j8; cd ..; \
         cd so3; make vexpress_fb_defconfig; make -j8; cd ..; \
         cd usr; ./build.sh
diff -Naru ../so3.base/so3/arch/arm32/context.S ./so3/arch/arm32/context.S
--- ../so3.base/so3/arch/arm32/context.S	2023-03-31 13:07:30.754172712 +0200
+++ ./so3/arch/arm32/context.S	2023-04-02 13:30:44.697258301 +0200
@@ -280,7 +280,7 @@
 	.equ welcome_len, . - .LC_welcome
 
 .LC_exec:
-	.string "sh.elf"
+	.string "stress.elf"
 
 .LCnoshell:
 	.string "so3: No init proc(shell) found ...\n"
diff -Naru ../so3.base/so3/devices/fb/pl111.c ./so3/devices/fb/pl111.c
--- ../so3.base/so3/devices/fb/pl111.c	2023-03-31 13:07:30.754172712 +0200
+++ ./so3/devices/fb/pl111.c	2023-04-02 13:31:08.824654469 +0200
@@ -99,9 +99,59 @@
 void *fb_mmap(int fd, addr_t virt_addr, uint32_t page_count);
 int fb_ioctl(int fd, unsigned long cmd, unsigned long args);
 
+static addr_t __vaddr;
+
+void *fb_mmap(int fd, addr_t virt_addr, uint32_t page_count)
+{
+	uint32_t i, page;
+	pcb_t *pcb = current()->pcb;
+
+	/* Just for doing some test with performance analysis */
+	virt_addr = malloc(page_count*PAGE_SIZE);
+	BUG_ON(!virt_addr);
+#if 0
+	for (i = 0; i < page_count; i++) {
+		/* Map a process' virtual page to the physical one (here the VRAM). */
+		page = LCDUPBASE + i * PAGE_SIZE;
+		create_mapping(pcb->pgtable, virt_addr + (i * PAGE_SIZE), page, PAGE_SIZE, false);
+	}
+#endif
+
+	__vaddr = virt_addr;
+
+	return (void *) virt_addr;
+}
+
+int fb_ioctl(int fd, unsigned long cmd, unsigned long args)
+{
+	switch (cmd) {
+
+	case IOCTL_HRES:
+		*((uint32_t *) args) = HRES;
+		return 0;
+
+	case IOCTL_VRES:
+		*((uint32_t *) args) = VRES;
+		return 0;
+
+	case IOCTL_SIZE:
+		*((uint32_t *) args) = HRES * VRES * 4; /* assume 24bpp */
+		return 0;
+
+	default:
+		/* Unknown command. */
+		return -1;
+	}
+}
+
+int fb_close(int fd) {
+	free((void *) __vaddr);
+}
+
 struct file_operations pl111_fops = {
 	.mmap = fb_mmap,
-	.ioctl = fb_ioctl
+	.ioctl = fb_ioctl,
+	.close = fb_close
 };
 
 struct devclass pl111_cdev = {
@@ -110,7 +160,6 @@
 	.fops = &pl111_fops,
 };
 
-
 /*
  * Initialisation of the PL111 CLCD Controller.
  * Linux driver: video/fbdev/amba-clcd.c
@@ -157,44 +206,4 @@
 	return 0;
 }
 
-void *fb_mmap(int fd, addr_t virt_addr, uint32_t page_count)
-{
-	uint32_t i, page;
-	pcb_t *pcb = current()->pcb;
-
-	virt_addr = malloc(page_count*PAGE_SIZE);
-	BUG_ON(!virt_addr);
-#if 0
-	for (i = 0; i < page_count; i++) {
-		/* Map a process' virtual page to the physical one (here the VRAM). */
-		page = LCDUPBASE + i * PAGE_SIZE;
-		create_mapping(pcb->pgtable, virt_addr + (i * PAGE_SIZE), page, PAGE_SIZE, false);
-	}
-#endif
-
-	return (void *) virt_addr;
-}
-
-int fb_ioctl(int fd, unsigned long cmd, unsigned long args)
-{
-	switch (cmd) {
-
-	case IOCTL_HRES:
-		*((uint32_t *) args) = HRES;
-		return 0;
-
-	case IOCTL_VRES:
-		*((uint32_t *) args) = VRES;
-		return 0;
-
-	case IOCTL_SIZE:
-		*((uint32_t *) args) = HRES * VRES * 4; /* assume 24bpp */
-		return 0;
-
-	default:
-		/* Unknown command. */
-		return -1;
-	}
-}
-
 REGISTER_DRIVER_POSTCORE("arm,pl111", pl111_init);
diff -Naru ../so3.base/so3/kernel/process.c ./so3/kernel/process.c
--- ../so3.base/so3/kernel/process.c	2023-03-31 13:07:30.758172601 +0200
+++ ./so3/kernel/process.c	2023-04-02 13:30:37.853429741 +0200
@@ -848,10 +848,18 @@
 	pcb_t *pcb;
 	unsigned i;
 
+	register int reg0 asm("r0");
+	register int reg1 asm("r1");
+
 	pcb = current()->pcb;
 
 	/* Never finish the root process */
 	if (pcb->parent == NULL) {
+		reg0 = 0x18;    // angel_SWIreason_ReportException
+		reg1 = 0x20026; // ADP_Stopped_ApplicationExit
+
+		asm("svc 0x00123456");  // make semihosting call
+
 		printk("<kernel> %s: cannot finish the root process ...\n", __func__);
 		kernel_panic();
 	}
diff -Naru ../so3.base/so3_ci.patch ./so3_ci.patch
--- ../so3.base/so3_ci.patch	1970-01-01 01:00:00.000000000 +0100
+++ ./so3_ci.patch	2023-04-07 13:57:53.878359557 +0200
@@ -0,0 +1,175 @@
+diff -Naru ../so3.base/Dockerfile ./Dockerfile
+--- ../so3.base/Dockerfile	2023-04-02 13:19:24.698875432 +0200
++++ ./Dockerfile	2023-04-02 13:18:33.832210718 +0200
+@@ -9,14 +9,16 @@
+     bridge-utils iptables dnsmasq \
+     util-linux qemu-system-arm
+ 
+-RUN cd /; \
+-    wget https://github.com/smartobjectoriented/so3/archive/refs/heads/master.zip; \
+-    unzip master.zip; mv so3-master so3
++COPY        / /so3
+ 
+ WORKDIR so3
+ 
+ RUN     find / -name thumb | xargs rm -r; \
+-        patch -s -p0 < ci/so3_ci.patch; \
++        cd filesystem; patch -s -p0 < ../ci/filesystem.patch; cd ..; \
++        patch -p0 st ci/st.patch; \
++        patch -p0 deploy.sh ci/deploy.sh.patch; \
++        cd rootfs; patch -s -p0 < ../ci/rootfs.patch; cd ..; \
++        cd usr; patch -s -p0 < ../ci/usr.patch; cd ..; \
+         cd u-boot; make vexpress_defconfig; make -j8; cd ..; \
+         cd so3; make vexpress_fb_defconfig; make -j8; cd ..; \
+         cd usr; ./build.sh
+diff -Naru ../so3.base/so3/arch/arm32/context.S ./so3/arch/arm32/context.S
+--- ../so3.base/so3/arch/arm32/context.S	2023-03-31 13:07:30.754172712 +0200
++++ ./so3/arch/arm32/context.S	2023-04-02 13:30:44.697258301 +0200
+@@ -280,7 +280,7 @@
+ 	.equ welcome_len, . - .LC_welcome
+ 
+ .LC_exec:
+-	.string "sh.elf"
++	.string "stress.elf"
+ 
+ .LCnoshell:
+ 	.string "so3: No init proc(shell) found ...\n"
+diff -Naru ../so3.base/so3/devices/fb/pl111.c ./so3/devices/fb/pl111.c
+--- ../so3.base/so3/devices/fb/pl111.c	2023-03-31 13:07:30.754172712 +0200
++++ ./so3/devices/fb/pl111.c	2023-04-02 13:31:08.824654469 +0200
+@@ -99,9 +99,59 @@
+ void *fb_mmap(int fd, addr_t virt_addr, uint32_t page_count);
+ int fb_ioctl(int fd, unsigned long cmd, unsigned long args);
+ 
++static addr_t __vaddr;
++
++void *fb_mmap(int fd, addr_t virt_addr, uint32_t page_count)
++{
++	uint32_t i, page;
++	pcb_t *pcb = current()->pcb;
++
++	/* Just for doing some test with performance analysis */
++	virt_addr = malloc(page_count*PAGE_SIZE);
++	BUG_ON(!virt_addr);
++#if 0
++	for (i = 0; i < page_count; i++) {
++		/* Map a process' virtual page to the physical one (here the VRAM). */
++		page = LCDUPBASE + i * PAGE_SIZE;
++		create_mapping(pcb->pgtable, virt_addr + (i * PAGE_SIZE), page, PAGE_SIZE, false);
++	}
++#endif
++
++	__vaddr = virt_addr;
++
++	return (void *) virt_addr;
++}
++
++int fb_ioctl(int fd, unsigned long cmd, unsigned long args)
++{
++	switch (cmd) {
++
++	case IOCTL_HRES:
++		*((uint32_t *) args) = HRES;
++		return 0;
++
++	case IOCTL_VRES:
++		*((uint32_t *) args) = VRES;
++		return 0;
++
++	case IOCTL_SIZE:
++		*((uint32_t *) args) = HRES * VRES * 4; /* assume 24bpp */
++		return 0;
++
++	default:
++		/* Unknown command. */
++		return -1;
++	}
++}
++
++int fb_close(int fd) {
++	free((void *) __vaddr);
++}
++
+ struct file_operations pl111_fops = {
+ 	.mmap = fb_mmap,
+-	.ioctl = fb_ioctl
++	.ioctl = fb_ioctl,
++	.close = fb_close
+ };
+ 
+ struct devclass pl111_cdev = {
+@@ -110,7 +160,6 @@
+ 	.fops = &pl111_fops,
+ };
+ 
+-
+ /*
+  * Initialisation of the PL111 CLCD Controller.
+  * Linux driver: video/fbdev/amba-clcd.c
+@@ -157,44 +206,4 @@
+ 	return 0;
+ }
+ 
+-void *fb_mmap(int fd, addr_t virt_addr, uint32_t page_count)
+-{
+-	uint32_t i, page;
+-	pcb_t *pcb = current()->pcb;
+-
+-	virt_addr = malloc(page_count*PAGE_SIZE);
+-	BUG_ON(!virt_addr);
+-#if 0
+-	for (i = 0; i < page_count; i++) {
+-		/* Map a process' virtual page to the physical one (here the VRAM). */
+-		page = LCDUPBASE + i * PAGE_SIZE;
+-		create_mapping(pcb->pgtable, virt_addr + (i * PAGE_SIZE), page, PAGE_SIZE, false);
+-	}
+-#endif
+-
+-	return (void *) virt_addr;
+-}
+-
+-int fb_ioctl(int fd, unsigned long cmd, unsigned long args)
+-{
+-	switch (cmd) {
+-
+-	case IOCTL_HRES:
+-		*((uint32_t *) args) = HRES;
+-		return 0;
+-
+-	case IOCTL_VRES:
+-		*((uint32_t *) args) = VRES;
+-		return 0;
+-
+-	case IOCTL_SIZE:
+-		*((uint32_t *) args) = HRES * VRES * 4; /* assume 24bpp */
+-		return 0;
+-
+-	default:
+-		/* Unknown command. */
+-		return -1;
+-	}
+-}
+-
+ REGISTER_DRIVER_POSTCORE("arm,pl111", pl111_init);
+diff -Naru ../so3.base/so3/kernel/process.c ./so3/kernel/process.c
+--- ../so3.base/so3/kernel/process.c	2023-03-31 13:07:30.758172601 +0200
++++ ./so3/kernel/process.c	2023-04-02 13:30:37.853429741 +0200
+@@ -848,10 +848,18 @@
+ 	pcb_t *pcb;
+ 	unsigned i;
+ 
++	register int reg0 asm("r0");
++	register int reg1 asm("r1");
++
+ 	pcb = current()->pcb;
+ 
+ 	/* Never finish the root process */
+ 	if (pcb->parent == NULL) {
++		reg0 = 0x18;    // angel_SWIreason_ReportException
++		reg1 = 0x20026; // ADP_Stopped_ApplicationExit
++
++		asm("svc 0x00123456");  // make semihosting call
++
+ 		printk("<kernel> %s: cannot finish the root process ...\n", __func__);
+ 		kernel_panic();
+ 	}
diff -Naru ../so3.base/st ./st
--- ../so3.base/st	2023-04-07 13:04:46.499063078 +0200
+++ ./st	2023-04-07 13:14:52.361191057 +0200
@@ -9,6 +9,7 @@
 QEMU_MAC_ADDR=`printf 'DE:AD:BE:EF:%02X:%02X\n' $(($RANDOM % 255)) $((N_QEMU_INSTANCES))`
 GDB_PORT=$(($GDB_PORT_BASE + $N_QEMU_INSTANCES))
 
+CHECKPERF_LOG="perf_check_$(date +"%Y_%m_%d_%I_%M_%S").log"
 
     echo -e "\033[01;36mMAC addr: " ${QEMU_MAC_ADDR} "\033[0;37m"
     echo -e "\033[01;36mGDB port: " ${GDB_PORT} "\033[0;37m"
@@ -35,18 +36,19 @@
         -gdb tcp::${GDB_PORT}
 
     else    
-   echo Starting on ARM32
-   sudo qemu-system-arm $@ ${USR_OPTION} \
-  	-smp 4 \
-	-serial mon:stdio  \
-	-M vexpress-a15,secure=on  -cpu cortex-a15 \
-	-m 1024 \
-	-kernel u-boot/u-boot \
-	-semihosting-config enable,target=native \
-	-net tap,script=scripts/qemu-ifup.sh,downscript=scripts/qemu-ifdown.sh -net nic,macaddr=${QEMU_MAC_ADDR} \
-	-sd filesystem/sdcard.img.vexpress \
-	-nographic \
-	-gdb tcp::${GDB_PORT}
+	echo Starting on ARM32
+
+	sudo qemu-system-arm $@ ${USR_OPTION} \
+  	-icount shift=auto,sleep=off \
+	-semihosting \
+	-chardev stdio,id=char0,mux=on,logfile=${CHECKPERF_LOG},signal=off \
+	-serial chardev:char0  \
+	-mon chardev=char0 \
+ 	-M vexpress-a15,secure=on  -cpu cortex-a15 \
+ 	-m 1024 \
+ 	-kernel u-boot/u-boot \
+ 	-sd filesystem/sdcard.img.vexpress \
+	-nographic > /dev/null
         
     fi
  
diff -Naru ../so3.base/usr/lib/CMakeLists.txt ./usr/lib/CMakeLists.txt
--- ../so3.base/usr/lib/CMakeLists.txt	2023-03-31 13:07:31.074163803 +0200
+++ ./usr/lib/CMakeLists.txt	2023-04-02 13:31:15.732481747 +0200
@@ -1,6 +1,5 @@
 
 add_subdirectory(libc)
 add_subdirectory(lvgl)
-add_subdirectory(libxml2)
 
                     
diff -Naru ../so3.base/usr/src/CMakeLists.txt ./usr/src/CMakeLists.txt
--- ../so3.base/usr/src/CMakeLists.txt	2023-04-07 13:57:43.986606187 +0200
+++ ./usr/src/CMakeLists.txt	2023-03-19 15:06:41.347458285 +0100
@@ -5,7 +5,6 @@
 add_executable(time.elf time.c)
 add_executable(ping.elf ping.c)
 
-add_subdirectory(widgets)
 add_subdirectory(stress)
 
 target_link_libraries(sh.elf c)
diff -Naru ../so3.base/usr/src/widgets/CMakeLists.txt ./usr/src/widgets/CMakeLists.txt
--- ../so3.base/usr/src/widgets/CMakeLists.txt	2023-03-31 13:07:31.154161577 +0200
+++ ./usr/src/widgets/CMakeLists.txt	2023-03-19 15:06:41.347458285 +0100
@@ -4,6 +4,10 @@
 #add_compile_options("-DLV_LVGL_H_INCLUDE_SIMPLE")
 
 add_compile_options("-DLV_USE_DEMO_WIDGETS") 
+
 add_executable(demofb.elf demofb.c lv_demo_widgets.c img_lvgl_logo.c img_demo_widgets_avatar.c img_clothes.c)
+add_executable(lvgl_perf.elf lvgl_perf.c lvgl_perf_drawing.c img_lvgl_logo.c)
+
 
-target_link_libraries(demofb.elf c lvgl)
\ No newline at end of file
+target_link_libraries(demofb.elf c lvgl)
+target_link_libraries(lvgl_perf.elf c lvgl)
\ No newline at end of file
diff -Naru ../so3.base/usr/src/widgets/lvgl_perf.c ./usr/src/widgets/lvgl_perf.c
--- ../so3.base/usr/src/widgets/lvgl_perf.c	1970-01-01 01:00:00.000000000 +0100
+++ ./usr/src/widgets/lvgl_perf.c	2023-03-10 13:24:05.353985296 +0100
@@ -0,0 +1,245 @@
+/*
+ * Copyright (C) 2020 Nikolaos Garanis <nikolaos.garanis@heig-vd.ch>
+ * Copyright (C) 2021 Daniel Rossier <daniel.rossier@heig-vd.ch>
+ *
+ * With the kind support and contribution of Gabor Kiss-Vamosi from LVGL. Thank You!
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+/*
+ * demo.c
+ *
+ * A more complete LittlevGL demo.
+ *
+ * Based on:
+ *  - https://github.com/littlevgl/lv_examples/blob/master/lv_tests/lv_test_theme/lv_test_theme_1.c
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <bits/ioctl_fix.h>
+#include <pthread.h>
+#include <time.h>
+#include <sys/time.h>
+
+#include <lvgl.h>
+
+
+#include "demofb.h"
+
+/* Screen resolution. */
+static uint32_t scr_hres, scr_vres, *fbp;
+
+/* File descriptor of the mouse and keyboard input device. */
+static int mfd;
+static int kfd;
+
+/* lvgl group for the keyboard. */
+static lv_group_t *keyboard_group;
+
+/* Tick routine for lvgl. */
+void *tick_routine(void *args)
+{
+	while (1) {
+		/* Tell LittlevGL that 5 milliseconds were elapsed */
+		usleep(1000);
+		lv_tick_inc(1);
+	}
+}
+
+/* File system driver initialisation. */
+void fs_init(void)
+{
+	static lv_fs_drv_t drv;
+	lv_fs_drv_init(&drv);
+
+	drv.letter = 'S';			/* An uppercase letter to identify the drive */
+	drv.ready_cb = fs_ready_cb;		/* Callback to tell if the drive is ready to use */
+
+	drv.open_cb = fs_open_cb;		/* Callback to open a file */
+	drv.close_cb = fs_close_cb;		/* Callback to close a file */
+	drv.read_cb = fs_read_cb;		/* Callback to read a file */
+	drv.seek_cb = fs_seek_cb;		/* Callback to seek in a file (Move cursor) */
+	drv.tell_cb = fs_tell_cb;		/* Callback to tell the cursor position */
+
+	lv_fs_drv_register(&drv);
+}
+
+bool fs_ready_cb(struct _lv_fs_drv_t *drv)
+{
+	return true;
+}
+
+void *fs_open_cb(struct _lv_fs_drv_t *drv, const char *path, lv_fs_mode_t mode)
+{
+	FILE *fp = fopen(path, (mode & LV_FS_MODE_WR) ? "w" : "r");
+	if (!fp) {
+		return NULL;
+	}
+
+	return fp;
+}
+
+lv_fs_res_t fs_close_cb(struct _lv_fs_drv_t *drv, void *file_p)
+{
+	if (0 != fclose(file_p)) {
+		return LV_FS_RES_UNKNOWN;
+	}
+
+	return LV_FS_RES_OK;
+}
+
+lv_fs_res_t fs_read_cb(struct _lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btr, uint32_t *br)
+{
+	*br = fread(buf, sizeof(uint8_t), btr, file_p);
+	return LV_FS_RES_OK;
+}
+
+lv_fs_res_t fs_seek_cb(struct _lv_fs_drv_t *drv, void *file_p, uint32_t pos, lv_fs_whence_t whence)
+{
+	if (0 != fseek(file_p, pos, SEEK_SET)) {
+		return LV_FS_RES_UNKNOWN;
+	}
+
+	return LV_FS_RES_OK;
+}
+
+lv_fs_res_t fs_tell_cb(struct _lv_fs_drv_t *drv, void *file_p, uint32_t *pos_p)
+{
+	*pos_p = ftell(file_p);
+	return LV_FS_RES_OK;
+}
+
+
+/*
+ * Framebuffer and display initialisation.
+ */
+int fb_init(void)
+{
+	int fd;
+	uint32_t fb_size;
+	static lv_disp_drv_t disp_drv;
+
+	/* LVGL will use this buffer to render the screen. See my_fb_cb. */
+	static lv_color_t buf[LVGL_BUF_SIZE];
+	static lv_disp_draw_buf_t disp_buf;
+
+	/* Get file descriptor. */
+	fd = open("/dev/fb0", 0);
+	if (-1 == fd) {
+		printf("Couldn't open framebuffer.\n");
+		return -1;
+	}
+
+	/* Get screen resolution. */
+	if (ioctl(fd, IOCTL_FB_HRES, &scr_hres)
+		|| ioctl(fd, IOCTL_FB_VRES, &scr_vres)
+		|| ioctl(fd, IOCTL_FB_SIZE, &fb_size)) {
+
+		printf("Couldn't get framebuffer resolution.\n");
+		return -1;
+	}
+
+	/* Map the framebuffer into process memory. */
+	fbp = mmap(NULL, fb_size, 0, 0, fd, 0);
+	if (!fbp) {
+		printf("Couldn't map framebuffer.\n");
+		return -1;
+	}
+
+	lv_disp_draw_buf_init(&disp_buf, buf, NULL, LVGL_BUF_SIZE);
+
+	/*
+	 * Initialisation and registration of the display driver.
+	 * Also setting the flush callback function (flush_cb) which will write
+	 * the lvgl buffer (buf) into our real framebuffer.
+	 */
+
+	lv_disp_drv_init(&disp_drv);
+	disp_drv.hor_res = scr_hres;
+	disp_drv.ver_res = scr_vres;
+	disp_drv.draw_buf = &disp_buf;
+	disp_drv.flush_cb = my_fb_cb;
+	lv_disp_drv_register(&disp_drv);
+
+	return 0;
+}
+
+/*
+ * Framebuffer callback. LVGL calls this function to redraw a screen area. If
+ * the buffer given to LVGL is smaller than the framebuffer, this function will
+ * be called multiple times until the whole screen has been redrawn. This is
+ * why we cannot use memcpy to redraw the whole region, we have to do it line
+ * by line.
+ *
+ * If the buffer is the size of the framebuffer, we could use memcpy for the
+ * whole region, but then SO3 would require more memory.
+ *
+ * https://docs.lvgl.io/latest/en/html/porting/display.html#display-buffer
+ */
+void my_fb_cb(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)
+{
+	lv_coord_t y, w = lv_area_get_width(area);
+	uint32_t line_size = w * sizeof(lv_color_t);
+
+	for (y = area->y1; y <= area->y2; y++) {
+		memcpy(&fbp[y * scr_hres + area->x1], color_p, line_size);
+		color_p += w;
+	}
+
+	lv_disp_flush_ready(disp);
+}
+
+/* Main code. */
+
+int main(int argc, char **argv)
+{
+	pthread_t tick_thread;
+	struct timeval tv_start, tv_end;
+
+	/* Initialisation of lvgl. */
+	lv_init();
+	fs_init();
+
+	/* Initialisation of the framebuffer, mouse and keyboard. */
+	if (fb_init())
+		return -1;
+
+	gettimeofday(&tv_start, NULL);
+
+	/* Creating the UI. */
+	lv_demo_stress();
+
+	gettimeofday(&tv_end, NULL);
+
+	printf("## Elapsed time: %lld microseconds.\n", tv_end.tv_usec - tv_start.tv_usec);
+
+	/* LittlevGL needs to know how time passes by. */
+	if (pthread_create(&tick_thread, NULL, tick_routine, NULL) == -1) {
+		return -1;
+	}
+
+	/* LittlevGL has a set of tasks it needs to run every 5ms approx. */
+	while (1) {
+		lv_task_handler();
+		usleep(5000);
+	}
+
+	return 0;
+}
diff -Naru ../so3.base/usr/src/widgets/lvgl_perf_drawing.c ./usr/src/widgets/lvgl_perf_drawing.c
--- ../so3.base/usr/src/widgets/lvgl_perf_drawing.c	1970-01-01 01:00:00.000000000 +0100
+++ ./usr/src/widgets/lvgl_perf_drawing.c	2023-03-10 13:20:15.074867284 +0100
@@ -0,0 +1,133 @@
+/**
+ * @file lv_demo_widgets.c
+ *
+ */
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "lv_demo_widgets.h"
+
+
+#if LV_USE_BUILTIN_MALLOC && LV_MEM_SIZE < (38ul * 1024ul)
+    #error Insufficient memory for lv_demo_widgets. Please set LV_MEM_SIZE to at least 38KB (38ul * 1024ul).  48KB is recommended.
+#endif
+
+/*********************
+ *      DEFINES
+ *********************/
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+typedef enum {
+    DISP_SMALL,
+    DISP_MEDIUM,
+    DISP_LARGE,
+} disp_size_t;
+
+
+
+/**********************
+ *  STATIC VARIABLES
+ **********************/
+static disp_size_t disp_size;
+
+static lv_obj_t * tv;
+static lv_obj_t * calendar;
+static lv_style_t style_text_muted;
+static lv_style_t style_title;
+static lv_style_t style_icon;
+static lv_style_t style_bullet;
+
+
+
+static const lv_font_t * font_large;
+static const lv_font_t * font_normal;
+
+static uint32_t session_desktop = 1000;
+static uint32_t session_tablet = 1000;
+static uint32_t session_mobile = 1000;
+
+/**********************
+ *      MACROS
+ **********************/
+
+/**********************
+ *   GLOBAL FUNCTIONS
+ **********************/
+
+void lv_demo_widgets(void)
+{
+    if(LV_HOR_RES <= 320) disp_size = DISP_SMALL;
+    else if(LV_HOR_RES < 720) disp_size = DISP_MEDIUM;
+    else disp_size = DISP_LARGE;
+
+    font_large = LV_FONT_DEFAULT;
+    font_normal = LV_FONT_DEFAULT;
+
+    lv_coord_t tab_h;
+    if(disp_size == DISP_LARGE) {
+        tab_h = 70;
+
+        font_large     = &lv_font_montserrat_24;
+
+
+        font_normal    = &lv_font_montserrat_16;
+
+    }
+    else if(disp_size == DISP_MEDIUM) {
+        tab_h = 45;
+
+        LV_LOG_WARN("LV_FONT_MONTSERRAT_20 is not enabled for the widgets demo. Using LV_FONT_DEFAULT instead.");
+        font_normal    = &lv_font_montserrat_14;
+
+    }
+    else {   /* disp_size == DISP_SMALL */
+        tab_h = 45;
+
+        font_large     = &lv_font_montserrat_18;
+        font_normal    = &lv_font_montserrat_12;
+
+    }
+
+#if LV_USE_THEME_DEFAULT
+    lv_theme_default_init(NULL, lv_palette_main(LV_PALETTE_BLUE), lv_palette_main(LV_PALETTE_RED), LV_THEME_DEFAULT_DARK,
+                          font_normal);
+#endif
+
+    lv_style_init(&style_text_muted);
+    lv_style_set_text_opa(&style_text_muted, LV_OPA_50);
+
+    lv_style_init(&style_title);
+    lv_style_set_text_font(&style_title, font_large);
+
+    lv_style_init(&style_icon);
+    lv_style_set_text_color(&style_icon, lv_theme_get_color_primary(NULL));
+    lv_style_set_text_font(&style_icon, font_large);
+
+    lv_style_init(&style_bullet);
+    lv_style_set_border_width(&style_bullet, 0);
+    lv_style_set_radius(&style_bullet, LV_RADIUS_CIRCLE);
+
+    /*Create an array for the points of the line*/
+        static lv_point_t line_points[] = { {5, 5}, {70, 70}, {120, 10}, {180, 60}, {240, 10} };
+
+        /*Create style*/
+        static lv_style_t style_line;
+        lv_style_init(&style_line);
+        lv_style_set_line_width(&style_line, LV_STATE_DEFAULT, 8);
+        lv_style_set_line_color(&style_line, LV_STATE_DEFAULT, LV_COLOR_BLUE);
+        lv_style_set_line_rounded(&style_line, LV_STATE_DEFAULT, true);
+
+        /*Create a line and apply the new style*/
+        lv_obj_t * line1;
+        line1 = lv_line_create(lv_scr_act());
+        lv_line_set_points(line1, line_points, 5);     /*Set the points*/
+        lv_obj_add_style(line1, LV_LINE_PART_MAIN, &style_line);     /*Set the points*/
+        lv_obj_align(line1, LV_ALIGN_CENTER, 0, 0);
+
+
+}
+
+
