diff -Naur ../so3.base/qemu/build.sh ./qemu/build.sh
--- ../so3.base/qemu/build.sh	2023-06-30 11:52:00.139967146 +0200
+++ ./qemu/build.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-wget https://download.qemu.org/qemu-8.0.0.tar.xz
-tar xf qemu-8.0.0.tar.xz
-mv qemu-8.0.0 qemu
-rm qemu-8.0.0.tar.xz
diff -Naur ../so3.base/qemu/qemu.patch ./qemu/qemu.patch
--- ../so3.base/qemu/qemu.patch	2023-06-30 11:57:17.245313125 +0200
+++ ./qemu/qemu.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,192 +0,0 @@
-diff -Naur ../qemu.clean/hw/arm/virt.c ./hw/arm/virt.c
---- ../qemu.clean/hw/arm/virt.c	2023-04-19 18:31:47.000000000 +0200
-+++ ./hw/arm/virt.c	2023-06-30 11:36:55.952744365 +0200
-@@ -81,6 +81,8 @@
- #include "hw/char/pl011.h"
- #include "qemu/guest-random.h"
- 
-+#include "hw/input/ps2.h"
-+
- #define DEFINE_VIRT_MACHINE_LATEST(major, minor, latest) \
-     static void virt_##major##_##minor##_class_init(ObjectClass *oc, \
-                                                     void *data) \
-@@ -144,6 +146,11 @@
-     [VIRT_GIC_ITS] =            { 0x08080000, 0x00020000 },
-     /* This redistributor space allows up to 2*64kB*123 CPUs */
-     [VIRT_GIC_REDIST] =         { 0x080A0000, 0x00F60000 },
-+
-+	[VIRT_CLCD] = 				{ 0x08800000, 0x00001000 },
-+	[VIRT_KMI0] = 				{ 0x08801000, 0x00001000 },
-+	[VIRT_KMI1] = 				{ 0x08802000, 0x00001000 },
-+
-     [VIRT_UART] =               { 0x09000000, 0x00001000 },
-     [VIRT_RTC] =                { 0x09010000, 0x00001000 },
-     [VIRT_FW_CFG] =             { 0x09020000, 0x00000018 },
-@@ -198,6 +205,11 @@
-     [VIRT_SECURE_UART] = 8,
-     [VIRT_ACPI_GED] = 9,
-     [VIRT_MMIO] = 16, /* ...to 16 + NUM_VIRTIO_TRANSPORTS - 1 */
-+
-+	[VIRT_CLCD] = 35,
-+	[VIRT_KMI0] = 36,
-+	[VIRT_KMI1] = 37,
-+
-     [VIRT_GIC_V2M] = 48, /* ...to 48 + NUM_GICV2M_SPIS - 1 */
-     [VIRT_SMMU] = 74,    /* ...to 74 + NUM_SMMU_IRQS - 1 */
-     [VIRT_PLATFORM_BUS] = 112, /* ...to 112 + PLATFORM_BUS_NUM_IRQS -1 */
-@@ -2018,6 +2030,14 @@
-     }
- }
- 
-+struct IRQState {
-+    Object parent_obj;
-+
-+    qemu_irq_handler handler;
-+    void *opaque;
-+    int n;
-+};
-+
- static void machvirt_init(MachineState *machine)
- {
-     VirtMachineState *vms = VIRT_MACHINE(machine);
-@@ -2326,6 +2346,27 @@
-                                vms->fw_cfg, OBJECT(vms));
-     }
- 
-+    {
-+    	   MemoryRegion *sysmem = get_system_memory();
-+    	   MemoryRegion *vram = g_new(MemoryRegion, 1);
-+    	   ram_addr_t vram_size;
-+
-+    	   vram_size = 0x800000;
-+
-+    	   memory_region_init_ram(vram, NULL, "virt.vram", vram_size, NULL);
-+    	   memory_region_add_subregion(sysmem, 0x30000000, vram);
-+
-+    	   sysbus_create_simple("pl111", (hwaddr) vms->memmap[VIRT_CLCD].base, NULL);
-+
-+    	   sysbus_create_simple("pl050_keyboard", (hwaddr) vms->memmap[VIRT_KMI0].base,
-+    			   qdev_get_gpio_in(vms->gic, vms->irqmap[VIRT_KMI0]));
-+
-+
-+    	   sysbus_create_simple("pl050_mouse", (hwaddr) vms->memmap[VIRT_KMI1].base,
-+    			   qdev_get_gpio_in(vms->gic, vms->irqmap[VIRT_KMI1]));
-+
-+    }
-+
-     vms->bootinfo.ram_size = machine->ram_size;
-     vms->bootinfo.board_id = -1;
-     vms->bootinfo.loader_start = vms->memmap[VIRT_MEM].base;
-diff -Naur ../qemu.clean/include/hw/arm/virt.h ./include/hw/arm/virt.h
---- ../qemu.clean/include/hw/arm/virt.h	2023-04-19 18:31:47.000000000 +0200
-+++ ./include/hw/arm/virt.h	2023-06-30 11:36:56.054742478 +0200
-@@ -68,6 +68,11 @@
-     VIRT_GIC_VCPU,
-     VIRT_GIC_ITS,
-     VIRT_GIC_REDIST,
-+
-+	VIRT_CLCD,
-+	VIRT_KMI0,
-+	VIRT_KMI1,
-+
-     VIRT_SMMU,
-     VIRT_UART,
-     VIRT_MMIO,
-diff -Naur ../qemu.clean/qemu.patch ./qemu.patch
---- ../qemu.clean/qemu.patch	1970-01-01 01:00:00.000000000 +0100
-+++ ./qemu.patch	2023-06-30 11:57:17.153315365 +0200
-@@ -0,0 +1,94 @@
-+diff -Naur ../qemu.clean/hw/arm/virt.c ./hw/arm/virt.c
-+--- ../qemu.clean/hw/arm/virt.c	2023-04-19 18:31:47.000000000 +0200
-++++ ./hw/arm/virt.c	2023-06-30 11:36:55.952744365 +0200
-+@@ -81,6 +81,8 @@
-+ #include "hw/char/pl011.h"
-+ #include "qemu/guest-random.h"
-+ 
-++#include "hw/input/ps2.h"
-++
-+ #define DEFINE_VIRT_MACHINE_LATEST(major, minor, latest) \
-+     static void virt_##major##_##minor##_class_init(ObjectClass *oc, \
-+                                                     void *data) \
-+@@ -144,6 +146,11 @@
-+     [VIRT_GIC_ITS] =            { 0x08080000, 0x00020000 },
-+     /* This redistributor space allows up to 2*64kB*123 CPUs */
-+     [VIRT_GIC_REDIST] =         { 0x080A0000, 0x00F60000 },
-++
-++	[VIRT_CLCD] = 				{ 0x08800000, 0x00001000 },
-++	[VIRT_KMI0] = 				{ 0x08801000, 0x00001000 },
-++	[VIRT_KMI1] = 				{ 0x08802000, 0x00001000 },
-++
-+     [VIRT_UART] =               { 0x09000000, 0x00001000 },
-+     [VIRT_RTC] =                { 0x09010000, 0x00001000 },
-+     [VIRT_FW_CFG] =             { 0x09020000, 0x00000018 },
-+@@ -198,6 +205,11 @@
-+     [VIRT_SECURE_UART] = 8,
-+     [VIRT_ACPI_GED] = 9,
-+     [VIRT_MMIO] = 16, /* ...to 16 + NUM_VIRTIO_TRANSPORTS - 1 */
-++
-++	[VIRT_CLCD] = 35,
-++	[VIRT_KMI0] = 36,
-++	[VIRT_KMI1] = 37,
-++
-+     [VIRT_GIC_V2M] = 48, /* ...to 48 + NUM_GICV2M_SPIS - 1 */
-+     [VIRT_SMMU] = 74,    /* ...to 74 + NUM_SMMU_IRQS - 1 */
-+     [VIRT_PLATFORM_BUS] = 112, /* ...to 112 + PLATFORM_BUS_NUM_IRQS -1 */
-+@@ -2018,6 +2030,14 @@
-+     }
-+ }
-+ 
-++struct IRQState {
-++    Object parent_obj;
-++
-++    qemu_irq_handler handler;
-++    void *opaque;
-++    int n;
-++};
-++
-+ static void machvirt_init(MachineState *machine)
-+ {
-+     VirtMachineState *vms = VIRT_MACHINE(machine);
-+@@ -2326,6 +2346,27 @@
-+                                vms->fw_cfg, OBJECT(vms));
-+     }
-+ 
-++    {
-++    	   MemoryRegion *sysmem = get_system_memory();
-++    	   MemoryRegion *vram = g_new(MemoryRegion, 1);
-++    	   ram_addr_t vram_size;
-++
-++    	   vram_size = 0x800000;
-++
-++    	   memory_region_init_ram(vram, NULL, "virt.vram", vram_size, NULL);
-++    	   memory_region_add_subregion(sysmem, 0x30000000, vram);
-++
-++    	   sysbus_create_simple("pl111", (hwaddr) vms->memmap[VIRT_CLCD].base, NULL);
-++
-++    	   sysbus_create_simple("pl050_keyboard", (hwaddr) vms->memmap[VIRT_KMI0].base,
-++    			   qdev_get_gpio_in(vms->gic, vms->irqmap[VIRT_KMI0]));
-++
-++
-++    	   sysbus_create_simple("pl050_mouse", (hwaddr) vms->memmap[VIRT_KMI1].base,
-++    			   qdev_get_gpio_in(vms->gic, vms->irqmap[VIRT_KMI1]));
-++
-++    }
-++
-+     vms->bootinfo.ram_size = machine->ram_size;
-+     vms->bootinfo.board_id = -1;
-+     vms->bootinfo.loader_start = vms->memmap[VIRT_MEM].base;
-+diff -Naur ../qemu.clean/include/hw/arm/virt.h ./include/hw/arm/virt.h
-+--- ../qemu.clean/include/hw/arm/virt.h	2023-04-19 18:31:47.000000000 +0200
-++++ ./include/hw/arm/virt.h	2023-06-30 11:36:56.054742478 +0200
-+@@ -68,6 +68,11 @@
-+     VIRT_GIC_VCPU,
-+     VIRT_GIC_ITS,
-+     VIRT_GIC_REDIST,
-++
-++	VIRT_CLCD,
-++	VIRT_KMI0,
-++	VIRT_KMI1,
-++
-+     VIRT_SMMU,
-+     VIRT_UART,
-+     VIRT_MMIO,
diff -Naur ../so3.base/qemu/README.so3 ./qemu/README.so3
--- ../so3.base/qemu/README.so3	2023-06-30 11:58:34.522430073 +0200
+++ ./qemu/README.so3	1970-01-01 01:00:00.000000000 +0100
@@ -1,19 +0,0 @@
-Read the documentation in qemu-doc.html or on http://wiki.qemu.org
-
-- QEMU team
-
-- Need the SDL library
-sudo apt-get install libsdl1.2-dev
-
-Configure options:
-
-AArch32 version:
-
-./configure --target-list=arm-softmmu --disable-attr --disable-werror --disable-docs
-
-AArch64 version:
-
-./configure --target-list=aarch64-softmmu --disable-attr --disable-werror --disable-docs
-
-
-
diff -Naur ../so3.base/so3/arch/arm32/context.S ./so3/arch/arm32/context.S
--- ../so3.base/so3/arch/arm32/context.S	2023-06-30 11:28:35.952058510 +0200
+++ ./so3/arch/arm32/context.S	2023-06-30 11:20:33.242667429 +0200
@@ -280,7 +280,7 @@
 	.equ welcome_len, . - .LC_welcome
 
 .LC_exec:
-	.string "sh.elf"
+	.string "stress.elf"
 
 .LCnoshell:
 	.string "so3: No init proc(shell) found ...\n"
diff -Naur ../so3.base/so3/devices/fb/pl111.c ./so3/devices/fb/pl111.c
--- ../so3.base/so3/devices/fb/pl111.c	2023-06-30 11:32:40.108465704 +0200
+++ ./so3/devices/fb/pl111.c	2023-06-30 11:32:39.754471734 +0200
@@ -107,10 +107,16 @@
 	uint32_t i, page;
 	pcb_t *pcb = current()->pcb;
 
+	/* Just for doing some test with performance analysis */
+	virt_addr = malloc(page_count*PAGE_SIZE);
+	BUG_ON(!virt_addr);
+#if 0
 	for (i = 0; i < page_count; i++) {
 		/* Map a process' virtual page to the physical one (here the VRAM). */
 		page = LCDUPBASE + i * PAGE_SIZE;
 		create_mapping(pcb->pgtable, virt_addr + (i * PAGE_SIZE), page, PAGE_SIZE, false);
+	}
+#endif
 
 	__vaddr = virt_addr;
 
diff -Naur ../so3.base/so3/kernel/process.c ./so3/kernel/process.c
--- ../so3.base/so3/kernel/process.c	2023-06-30 11:28:35.978058041 +0200
+++ ./so3/kernel/process.c	2023-06-30 11:25:57.456816584 +0200
@@ -848,10 +848,18 @@
 	pcb_t *pcb;
 	unsigned i;
 
+	register int reg0 asm("r0");
+	register int reg1 asm("r1");
+
 	pcb = current()->pcb;
 
 	/* Never finish the root process */
 	if (pcb->parent == NULL) {
+		reg0 = 0x18;    // angel_SWIreason_ReportException
+		reg1 = 0x20026; // ADP_Stopped_ApplicationExit
+
+		asm("svc 0x00123456");  // make semihosting call
+
 		printk("<kernel> %s: cannot finish the root process ...\n", __func__);
 		kernel_panic();
 	}
diff -Naur ../so3.base/so3_ci.patch ./so3_ci.patch
--- ../so3.base/so3_ci.patch	1970-01-01 01:00:00.000000000 +0100
+++ ./so3_ci.patch	2023-06-30 11:59:15.585427942 +0200
@@ -0,0 +1,281 @@
+diff -Naur ../so3.base/qemu/build.sh ./qemu/build.sh
+--- ../so3.base/qemu/build.sh	2023-06-30 11:52:00.139967146 +0200
++++ ./qemu/build.sh	1970-01-01 01:00:00.000000000 +0100
+@@ -1,4 +0,0 @@
+-wget https://download.qemu.org/qemu-8.0.0.tar.xz
+-tar xf qemu-8.0.0.tar.xz
+-mv qemu-8.0.0 qemu
+-rm qemu-8.0.0.tar.xz
+diff -Naur ../so3.base/qemu/qemu.patch ./qemu/qemu.patch
+--- ../so3.base/qemu/qemu.patch	2023-06-30 11:57:17.245313125 +0200
++++ ./qemu/qemu.patch	1970-01-01 01:00:00.000000000 +0100
+@@ -1,192 +0,0 @@
+-diff -Naur ../qemu.clean/hw/arm/virt.c ./hw/arm/virt.c
+---- ../qemu.clean/hw/arm/virt.c	2023-04-19 18:31:47.000000000 +0200
+-+++ ./hw/arm/virt.c	2023-06-30 11:36:55.952744365 +0200
+-@@ -81,6 +81,8 @@
+- #include "hw/char/pl011.h"
+- #include "qemu/guest-random.h"
+- 
+-+#include "hw/input/ps2.h"
+-+
+- #define DEFINE_VIRT_MACHINE_LATEST(major, minor, latest) \
+-     static void virt_##major##_##minor##_class_init(ObjectClass *oc, \
+-                                                     void *data) \
+-@@ -144,6 +146,11 @@
+-     [VIRT_GIC_ITS] =            { 0x08080000, 0x00020000 },
+-     /* This redistributor space allows up to 2*64kB*123 CPUs */
+-     [VIRT_GIC_REDIST] =         { 0x080A0000, 0x00F60000 },
+-+
+-+	[VIRT_CLCD] = 				{ 0x08800000, 0x00001000 },
+-+	[VIRT_KMI0] = 				{ 0x08801000, 0x00001000 },
+-+	[VIRT_KMI1] = 				{ 0x08802000, 0x00001000 },
+-+
+-     [VIRT_UART] =               { 0x09000000, 0x00001000 },
+-     [VIRT_RTC] =                { 0x09010000, 0x00001000 },
+-     [VIRT_FW_CFG] =             { 0x09020000, 0x00000018 },
+-@@ -198,6 +205,11 @@
+-     [VIRT_SECURE_UART] = 8,
+-     [VIRT_ACPI_GED] = 9,
+-     [VIRT_MMIO] = 16, /* ...to 16 + NUM_VIRTIO_TRANSPORTS - 1 */
+-+
+-+	[VIRT_CLCD] = 35,
+-+	[VIRT_KMI0] = 36,
+-+	[VIRT_KMI1] = 37,
+-+
+-     [VIRT_GIC_V2M] = 48, /* ...to 48 + NUM_GICV2M_SPIS - 1 */
+-     [VIRT_SMMU] = 74,    /* ...to 74 + NUM_SMMU_IRQS - 1 */
+-     [VIRT_PLATFORM_BUS] = 112, /* ...to 112 + PLATFORM_BUS_NUM_IRQS -1 */
+-@@ -2018,6 +2030,14 @@
+-     }
+- }
+- 
+-+struct IRQState {
+-+    Object parent_obj;
+-+
+-+    qemu_irq_handler handler;
+-+    void *opaque;
+-+    int n;
+-+};
+-+
+- static void machvirt_init(MachineState *machine)
+- {
+-     VirtMachineState *vms = VIRT_MACHINE(machine);
+-@@ -2326,6 +2346,27 @@
+-                                vms->fw_cfg, OBJECT(vms));
+-     }
+- 
+-+    {
+-+    	   MemoryRegion *sysmem = get_system_memory();
+-+    	   MemoryRegion *vram = g_new(MemoryRegion, 1);
+-+    	   ram_addr_t vram_size;
+-+
+-+    	   vram_size = 0x800000;
+-+
+-+    	   memory_region_init_ram(vram, NULL, "virt.vram", vram_size, NULL);
+-+    	   memory_region_add_subregion(sysmem, 0x30000000, vram);
+-+
+-+    	   sysbus_create_simple("pl111", (hwaddr) vms->memmap[VIRT_CLCD].base, NULL);
+-+
+-+    	   sysbus_create_simple("pl050_keyboard", (hwaddr) vms->memmap[VIRT_KMI0].base,
+-+    			   qdev_get_gpio_in(vms->gic, vms->irqmap[VIRT_KMI0]));
+-+
+-+
+-+    	   sysbus_create_simple("pl050_mouse", (hwaddr) vms->memmap[VIRT_KMI1].base,
+-+    			   qdev_get_gpio_in(vms->gic, vms->irqmap[VIRT_KMI1]));
+-+
+-+    }
+-+
+-     vms->bootinfo.ram_size = machine->ram_size;
+-     vms->bootinfo.board_id = -1;
+-     vms->bootinfo.loader_start = vms->memmap[VIRT_MEM].base;
+-diff -Naur ../qemu.clean/include/hw/arm/virt.h ./include/hw/arm/virt.h
+---- ../qemu.clean/include/hw/arm/virt.h	2023-04-19 18:31:47.000000000 +0200
+-+++ ./include/hw/arm/virt.h	2023-06-30 11:36:56.054742478 +0200
+-@@ -68,6 +68,11 @@
+-     VIRT_GIC_VCPU,
+-     VIRT_GIC_ITS,
+-     VIRT_GIC_REDIST,
+-+
+-+	VIRT_CLCD,
+-+	VIRT_KMI0,
+-+	VIRT_KMI1,
+-+
+-     VIRT_SMMU,
+-     VIRT_UART,
+-     VIRT_MMIO,
+-diff -Naur ../qemu.clean/qemu.patch ./qemu.patch
+---- ../qemu.clean/qemu.patch	1970-01-01 01:00:00.000000000 +0100
+-+++ ./qemu.patch	2023-06-30 11:57:17.153315365 +0200
+-@@ -0,0 +1,94 @@
+-+diff -Naur ../qemu.clean/hw/arm/virt.c ./hw/arm/virt.c
+-+--- ../qemu.clean/hw/arm/virt.c	2023-04-19 18:31:47.000000000 +0200
+-++++ ./hw/arm/virt.c	2023-06-30 11:36:55.952744365 +0200
+-+@@ -81,6 +81,8 @@
+-+ #include "hw/char/pl011.h"
+-+ #include "qemu/guest-random.h"
+-+ 
+-++#include "hw/input/ps2.h"
+-++
+-+ #define DEFINE_VIRT_MACHINE_LATEST(major, minor, latest) \
+-+     static void virt_##major##_##minor##_class_init(ObjectClass *oc, \
+-+                                                     void *data) \
+-+@@ -144,6 +146,11 @@
+-+     [VIRT_GIC_ITS] =            { 0x08080000, 0x00020000 },
+-+     /* This redistributor space allows up to 2*64kB*123 CPUs */
+-+     [VIRT_GIC_REDIST] =         { 0x080A0000, 0x00F60000 },
+-++
+-++	[VIRT_CLCD] = 				{ 0x08800000, 0x00001000 },
+-++	[VIRT_KMI0] = 				{ 0x08801000, 0x00001000 },
+-++	[VIRT_KMI1] = 				{ 0x08802000, 0x00001000 },
+-++
+-+     [VIRT_UART] =               { 0x09000000, 0x00001000 },
+-+     [VIRT_RTC] =                { 0x09010000, 0x00001000 },
+-+     [VIRT_FW_CFG] =             { 0x09020000, 0x00000018 },
+-+@@ -198,6 +205,11 @@
+-+     [VIRT_SECURE_UART] = 8,
+-+     [VIRT_ACPI_GED] = 9,
+-+     [VIRT_MMIO] = 16, /* ...to 16 + NUM_VIRTIO_TRANSPORTS - 1 */
+-++
+-++	[VIRT_CLCD] = 35,
+-++	[VIRT_KMI0] = 36,
+-++	[VIRT_KMI1] = 37,
+-++
+-+     [VIRT_GIC_V2M] = 48, /* ...to 48 + NUM_GICV2M_SPIS - 1 */
+-+     [VIRT_SMMU] = 74,    /* ...to 74 + NUM_SMMU_IRQS - 1 */
+-+     [VIRT_PLATFORM_BUS] = 112, /* ...to 112 + PLATFORM_BUS_NUM_IRQS -1 */
+-+@@ -2018,6 +2030,14 @@
+-+     }
+-+ }
+-+ 
+-++struct IRQState {
+-++    Object parent_obj;
+-++
+-++    qemu_irq_handler handler;
+-++    void *opaque;
+-++    int n;
+-++};
+-++
+-+ static void machvirt_init(MachineState *machine)
+-+ {
+-+     VirtMachineState *vms = VIRT_MACHINE(machine);
+-+@@ -2326,6 +2346,27 @@
+-+                                vms->fw_cfg, OBJECT(vms));
+-+     }
+-+ 
+-++    {
+-++    	   MemoryRegion *sysmem = get_system_memory();
+-++    	   MemoryRegion *vram = g_new(MemoryRegion, 1);
+-++    	   ram_addr_t vram_size;
+-++
+-++    	   vram_size = 0x800000;
+-++
+-++    	   memory_region_init_ram(vram, NULL, "virt.vram", vram_size, NULL);
+-++    	   memory_region_add_subregion(sysmem, 0x30000000, vram);
+-++
+-++    	   sysbus_create_simple("pl111", (hwaddr) vms->memmap[VIRT_CLCD].base, NULL);
+-++
+-++    	   sysbus_create_simple("pl050_keyboard", (hwaddr) vms->memmap[VIRT_KMI0].base,
+-++    			   qdev_get_gpio_in(vms->gic, vms->irqmap[VIRT_KMI0]));
+-++
+-++
+-++    	   sysbus_create_simple("pl050_mouse", (hwaddr) vms->memmap[VIRT_KMI1].base,
+-++    			   qdev_get_gpio_in(vms->gic, vms->irqmap[VIRT_KMI1]));
+-++
+-++    }
+-++
+-+     vms->bootinfo.ram_size = machine->ram_size;
+-+     vms->bootinfo.board_id = -1;
+-+     vms->bootinfo.loader_start = vms->memmap[VIRT_MEM].base;
+-+diff -Naur ../qemu.clean/include/hw/arm/virt.h ./include/hw/arm/virt.h
+-+--- ../qemu.clean/include/hw/arm/virt.h	2023-04-19 18:31:47.000000000 +0200
+-++++ ./include/hw/arm/virt.h	2023-06-30 11:36:56.054742478 +0200
+-+@@ -68,6 +68,11 @@
+-+     VIRT_GIC_VCPU,
+-+     VIRT_GIC_ITS,
+-+     VIRT_GIC_REDIST,
+-++
+-++	VIRT_CLCD,
+-++	VIRT_KMI0,
+-++	VIRT_KMI1,
+-++
+-+     VIRT_SMMU,
+-+     VIRT_UART,
+-+     VIRT_MMIO,
+diff -Naur ../so3.base/qemu/README.so3 ./qemu/README.so3
+--- ../so3.base/qemu/README.so3	2023-06-30 11:58:34.522430073 +0200
++++ ./qemu/README.so3	1970-01-01 01:00:00.000000000 +0100
+@@ -1,19 +0,0 @@
+-Read the documentation in qemu-doc.html or on http://wiki.qemu.org
+-
+-- QEMU team
+-
+-- Need the SDL library
+-sudo apt-get install libsdl1.2-dev
+-
+-Configure options:
+-
+-AArch32 version:
+-
+-./configure --target-list=arm-softmmu --disable-attr --disable-werror --disable-docs
+-
+-AArch64 version:
+-
+-./configure --target-list=aarch64-softmmu --disable-attr --disable-werror --disable-docs
+-
+-
+-
+diff -Naur ../so3.base/so3/arch/arm32/context.S ./so3/arch/arm32/context.S
+--- ../so3.base/so3/arch/arm32/context.S	2023-06-30 11:28:35.952058510 +0200
++++ ./so3/arch/arm32/context.S	2023-06-30 11:20:33.242667429 +0200
+@@ -280,7 +280,7 @@
+ 	.equ welcome_len, . - .LC_welcome
+ 
+ .LC_exec:
+-	.string "sh.elf"
++	.string "stress.elf"
+ 
+ .LCnoshell:
+ 	.string "so3: No init proc(shell) found ...\n"
+diff -Naur ../so3.base/so3/devices/fb/pl111.c ./so3/devices/fb/pl111.c
+--- ../so3.base/so3/devices/fb/pl111.c	2023-06-30 11:32:40.108465704 +0200
++++ ./so3/devices/fb/pl111.c	2023-06-30 11:32:39.754471734 +0200
+@@ -107,10 +107,16 @@
+ 	uint32_t i, page;
+ 	pcb_t *pcb = current()->pcb;
+ 
++	/* Just for doing some test with performance analysis */
++	virt_addr = malloc(page_count*PAGE_SIZE);
++	BUG_ON(!virt_addr);
++#if 0
+ 	for (i = 0; i < page_count; i++) {
+ 		/* Map a process' virtual page to the physical one (here the VRAM). */
+ 		page = LCDUPBASE + i * PAGE_SIZE;
+ 		create_mapping(pcb->pgtable, virt_addr + (i * PAGE_SIZE), page, PAGE_SIZE, false);
++	}
++#endif
+ 
+ 	__vaddr = virt_addr;
+ 
+diff -Naur ../so3.base/so3/kernel/process.c ./so3/kernel/process.c
+--- ../so3.base/so3/kernel/process.c	2023-06-30 11:28:35.978058041 +0200
++++ ./so3/kernel/process.c	2023-06-30 11:25:57.456816584 +0200
+@@ -848,10 +848,18 @@
+ 	pcb_t *pcb;
+ 	unsigned i;
+ 
++	register int reg0 asm("r0");
++	register int reg1 asm("r1");
++
+ 	pcb = current()->pcb;
+ 
+ 	/* Never finish the root process */
+ 	if (pcb->parent == NULL) {
++		reg0 = 0x18;    // angel_SWIreason_ReportException
++		reg1 = 0x20026; // ADP_Stopped_ApplicationExit
++
++		asm("svc 0x00123456");  // make semihosting call
++
+ 		printk("<kernel> %s: cannot finish the root process ...\n", __func__);
+ 		kernel_panic();
+ 	}
diff -Naur ../so3.base/st ./st
--- ../so3.base/st	2023-06-30 11:28:35.461067351 +0200
+++ ./st	2023-06-30 11:26:40.437041485 +0200
@@ -9,6 +9,7 @@
 QEMU_MAC_ADDR=`printf 'DE:AD:BE:EF:%02X:%02X\n' $(($RANDOM % 255)) $((N_QEMU_INSTANCES))`
 GDB_PORT=$(($GDB_PORT_BASE + $N_QEMU_INSTANCES))
 
+CHECKPERF_LOG="perf_check_$(date +"%Y_%m_%d_%I_%M_%S").log"
 
     echo -e "\033[01;36mMAC addr: " ${QEMU_MAC_ADDR} "\033[0;37m"
     echo -e "\033[01;36mGDB port: " ${GDB_PORT} "\033[0;37m"
@@ -36,17 +37,19 @@
 
     else    
    echo Starting on ARM32
-   sudo qemu/build/arm-softmmu/qemu-system-arm $@ ${USR_OPTION} \
-  	-smp 2 \
-	-serial mon:stdio  \
+   
+    sudo qemu/build/arm-softmmu/qemu-system-arm $@ ${USR_OPTION} \
+  	-icount shift=auto,sleep=off \
+	-semihosting \
+	-chardev stdio,id=char0,mux=on,logfile=${CHECKPERF_LOG},signal=off \
+	-serial chardev:char0  \
+	-mon chardev=char0 \
 	-M virt  -cpu cortex-a15 \
 	-device virtio-blk-device,drive=hd0 \
 	-drive if=none,file=filesystem/sdcard.img.virt32,id=hd0,format=raw,file.locking=off \
 	-m 1024 \
 	-bios u-boot/u-boot.bin \
-	-net tap,script=scripts/qemu-ifup.sh,downscript=scripts/qemu-ifdown.sh -net nic,macaddr=${QEMU_MAC_ADDR} \
-	-nographic \
-	-gdb tcp::${GDB_PORT}
+	-nographic > /dev/null
         
     fi
  
diff -Naur ../so3.base/usr/src/CMakeLists.txt ./usr/src/CMakeLists.txt
--- ../so3.base/usr/src/CMakeLists.txt	2023-06-30 11:28:36.274052711 +0200
+++ ./usr/src/CMakeLists.txt	2023-06-30 11:23:49.767119965 +0200
@@ -5,7 +5,6 @@
 add_executable(time.elf time.c)
 add_executable(ping.elf ping.c)
 
-add_subdirectory(widgets)
 add_subdirectory(stress)
 
 target_link_libraries(sh.elf c)
diff -Naur ../so3.base/usr/src/widgets/CMakeLists.txt ./usr/src/widgets/CMakeLists.txt
--- ../so3.base/usr/src/widgets/CMakeLists.txt	2023-06-30 11:28:36.265052874 +0200
+++ ./usr/src/widgets/CMakeLists.txt	2023-06-30 11:16:22.558198671 +0200
@@ -4,6 +4,10 @@
 #add_compile_options("-DLV_LVGL_H_INCLUDE_SIMPLE")
 
 add_compile_options("-DLV_USE_DEMO_WIDGETS") 
+
 add_executable(demofb.elf demofb.c lv_demo_widgets.c img_lvgl_logo.c img_demo_widgets_avatar.c img_clothes.c)
+add_executable(lvgl_perf.elf lvgl_perf.c lvgl_perf_drawing.c img_lvgl_logo.c)
+
 
-target_link_libraries(demofb.elf c lvgl)
\ No newline at end of file
+target_link_libraries(demofb.elf c lvgl)
+target_link_libraries(lvgl_perf.elf c lvgl)
diff -Naur ../so3.base/usr/src/widgets/demofb.c ./usr/src/widgets/demofb.c
--- ../so3.base/usr/src/widgets/demofb.c	2023-06-30 11:28:36.265052874 +0200
+++ ./usr/src/widgets/demofb.c	2023-06-30 11:23:18.848677863 +0200
@@ -55,7 +55,7 @@
 void *tick_routine(void *args)
 {
 	while (1) {
-		/* Tell LittlevGL that 1 millisecond were elapsed */
+		/* Tell LittlevGL that 5 milliseconds were elapsed */
 		usleep(1000);
 		lv_tick_inc(1);
 	}
@@ -72,7 +72,7 @@
 
 	drv.open_cb = fs_open_cb;		/* Callback to open a file */
 	drv.close_cb = fs_close_cb;		/* Callback to close a file */
-	drv.read_cb = fs_read_cb;
+	drv.read_cb = fs_read_cb;		/* Callback to read a file */
 	drv.seek_cb = fs_seek_cb;		/* Callback to seek in a file (Move cursor) */
 	drv.tell_cb = fs_tell_cb;		/* Callback to tell the cursor position */
 
@@ -154,8 +154,6 @@
 		return -1;
 	}
 
-	printf("Resolution: %d x %d\n", scr_hres, scr_vres);
-
 	/* Map the framebuffer into process memory. */
 	fbp = mmap(NULL, fb_size, 0, 0, fd, 0);
 	if (!fbp) {
@@ -308,7 +306,6 @@
 int main(int argc, char **argv)
 {
 	pthread_t tick_thread;
-	int x, y;
 
 	/* Initialisation of lvgl. */
 	lv_init();
diff -Naur ../so3.base/usr/src/widgets/lvgl_perf.c ./usr/src/widgets/lvgl_perf.c
--- ../so3.base/usr/src/widgets/lvgl_perf.c	1970-01-01 01:00:00.000000000 +0100
+++ ./usr/src/widgets/lvgl_perf.c	2023-04-07 13:06:50.872067219 +0200
@@ -0,0 +1,245 @@
+/*
+ * Copyright (C) 2020 Nikolaos Garanis <nikolaos.garanis@heig-vd.ch>
+ * Copyright (C) 2021 Daniel Rossier <daniel.rossier@heig-vd.ch>
+ *
+ * With the kind support and contribution of Gabor Kiss-Vamosi from LVGL. Thank You!
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+/*
+ * demo.c
+ *
+ * A more complete LittlevGL demo.
+ *
+ * Based on:
+ *  - https://github.com/littlevgl/lv_examples/blob/master/lv_tests/lv_test_theme/lv_test_theme_1.c
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <bits/ioctl_fix.h>
+#include <pthread.h>
+#include <time.h>
+#include <sys/time.h>
+
+#include <lvgl.h>
+
+
+#include "demofb.h"
+
+/* Screen resolution. */
+static uint32_t scr_hres, scr_vres, *fbp;
+
+/* File descriptor of the mouse and keyboard input device. */
+static int mfd;
+static int kfd;
+
+/* lvgl group for the keyboard. */
+static lv_group_t *keyboard_group;
+
+/* Tick routine for lvgl. */
+void *tick_routine(void *args)
+{
+	while (1) {
+		/* Tell LittlevGL that 5 milliseconds were elapsed */
+		usleep(1000);
+		lv_tick_inc(1);
+	}
+}
+
+/* File system driver initialisation. */
+void fs_init(void)
+{
+	static lv_fs_drv_t drv;
+	lv_fs_drv_init(&drv);
+
+	drv.letter = 'S';			/* An uppercase letter to identify the drive */
+	drv.ready_cb = fs_ready_cb;		/* Callback to tell if the drive is ready to use */
+
+	drv.open_cb = fs_open_cb;		/* Callback to open a file */
+	drv.close_cb = fs_close_cb;		/* Callback to close a file */
+	drv.read_cb = fs_read_cb;		/* Callback to read a file */
+	drv.seek_cb = fs_seek_cb;		/* Callback to seek in a file (Move cursor) */
+	drv.tell_cb = fs_tell_cb;		/* Callback to tell the cursor position */
+
+	lv_fs_drv_register(&drv);
+}
+
+bool fs_ready_cb(struct _lv_fs_drv_t *drv)
+{
+	return true;
+}
+
+void *fs_open_cb(struct _lv_fs_drv_t *drv, const char *path, lv_fs_mode_t mode)
+{
+	FILE *fp = fopen(path, (mode & LV_FS_MODE_WR) ? "w" : "r");
+	if (!fp) {
+		return NULL;
+	}
+
+	return fp;
+}
+
+lv_fs_res_t fs_close_cb(struct _lv_fs_drv_t *drv, void *file_p)
+{
+	if (0 != fclose(file_p)) {
+		return LV_FS_RES_UNKNOWN;
+	}
+
+	return LV_FS_RES_OK;
+}
+
+lv_fs_res_t fs_read_cb(struct _lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btr, uint32_t *br)
+{
+	*br = fread(buf, sizeof(uint8_t), btr, file_p);
+	return LV_FS_RES_OK;
+}
+
+lv_fs_res_t fs_seek_cb(struct _lv_fs_drv_t *drv, void *file_p, uint32_t pos, lv_fs_whence_t whence)
+{
+	if (0 != fseek(file_p, pos, SEEK_SET)) {
+		return LV_FS_RES_UNKNOWN;
+	}
+
+	return LV_FS_RES_OK;
+}
+
+lv_fs_res_t fs_tell_cb(struct _lv_fs_drv_t *drv, void *file_p, uint32_t *pos_p)
+{
+	*pos_p = ftell(file_p);
+	return LV_FS_RES_OK;
+}
+
+
+/*
+ * Framebuffer and display initialisation.
+ */
+int fb_init(void)
+{
+	int fd;
+	uint32_t fb_size;
+	static lv_disp_drv_t disp_drv;
+
+	/* LVGL will use this buffer to render the screen. See my_fb_cb. */
+	static lv_color_t buf[LVGL_BUF_SIZE];
+	static lv_disp_draw_buf_t disp_buf;
+
+	/* Get file descriptor. */
+	fd = open("/dev/fb0", 0);
+	if (-1 == fd) {
+		printf("Couldn't open framebuffer.\n");
+		return -1;
+	}
+
+	/* Get screen resolution. */
+	if (ioctl(fd, IOCTL_FB_HRES, &scr_hres)
+		|| ioctl(fd, IOCTL_FB_VRES, &scr_vres)
+		|| ioctl(fd, IOCTL_FB_SIZE, &fb_size)) {
+
+		printf("Couldn't get framebuffer resolution.\n");
+		return -1;
+	}
+
+	/* Map the framebuffer into process memory. */
+	fbp = mmap(NULL, fb_size, 0, 0, fd, 0);
+	if (!fbp) {
+		printf("Couldn't map framebuffer.\n");
+		return -1;
+	}
+
+	lv_disp_draw_buf_init(&disp_buf, buf, NULL, LVGL_BUF_SIZE);
+
+	/*
+	 * Initialisation and registration of the display driver.
+	 * Also setting the flush callback function (flush_cb) which will write
+	 * the lvgl buffer (buf) into our real framebuffer.
+	 */
+
+	lv_disp_drv_init(&disp_drv);
+	disp_drv.hor_res = scr_hres;
+	disp_drv.ver_res = scr_vres;
+	disp_drv.draw_buf = &disp_buf;
+	disp_drv.flush_cb = my_fb_cb;
+	lv_disp_drv_register(&disp_drv);
+
+	return 0;
+}
+
+/*
+ * Framebuffer callback. LVGL calls this function to redraw a screen area. If
+ * the buffer given to LVGL is smaller than the framebuffer, this function will
+ * be called multiple times until the whole screen has been redrawn. This is
+ * why we cannot use memcpy to redraw the whole region, we have to do it line
+ * by line.
+ *
+ * If the buffer is the size of the framebuffer, we could use memcpy for the
+ * whole region, but then SO3 would require more memory.
+ *
+ * https://docs.lvgl.io/latest/en/html/porting/display.html#display-buffer
+ */
+void my_fb_cb(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)
+{
+	lv_coord_t y, w = lv_area_get_width(area);
+	uint32_t line_size = w * sizeof(lv_color_t);
+
+	for (y = area->y1; y <= area->y2; y++) {
+		memcpy(&fbp[y * scr_hres + area->x1], color_p, line_size);
+		color_p += w;
+	}
+
+	lv_disp_flush_ready(disp);
+}
+
+/* Main code. */
+
+int main(int argc, char **argv)
+{
+	pthread_t tick_thread;
+	struct timeval tv_start, tv_end;
+
+	/* Initialisation of lvgl. */
+	lv_init();
+	fs_init();
+
+	/* Initialisation of the framebuffer, mouse and keyboard. */
+	if (fb_init())
+		return -1;
+
+	gettimeofday(&tv_start, NULL);
+
+	/* Creating the UI. */
+	lv_demo_stress();
+
+	gettimeofday(&tv_end, NULL);
+
+	printf("## Elapsed time: %lld microseconds.\n", tv_end.tv_usec - tv_start.tv_usec);
+
+	/* LittlevGL needs to know how time passes by. */
+	if (pthread_create(&tick_thread, NULL, tick_routine, NULL) == -1) {
+		return -1;
+	}
+
+	/* LittlevGL has a set of tasks it needs to run every 5ms approx. */
+	while (1) {
+		lv_task_handler();
+		usleep(5000);
+	}
+
+	return 0;
+}
diff -Naur ../so3.base/usr/src/widgets/lvgl_perf_drawing.c ./usr/src/widgets/lvgl_perf_drawing.c
--- ../so3.base/usr/src/widgets/lvgl_perf_drawing.c	1970-01-01 01:00:00.000000000 +0100
+++ ./usr/src/widgets/lvgl_perf_drawing.c	2023-04-07 13:06:50.868067316 +0200
@@ -0,0 +1,133 @@
+/**
+ * @file lv_demo_widgets.c
+ *
+ */
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "lv_demo_widgets.h"
+
+
+#if LV_USE_BUILTIN_MALLOC && LV_MEM_SIZE < (38ul * 1024ul)
+    #error Insufficient memory for lv_demo_widgets. Please set LV_MEM_SIZE to at least 38KB (38ul * 1024ul).  48KB is recommended.
+#endif
+
+/*********************
+ *      DEFINES
+ *********************/
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+typedef enum {
+    DISP_SMALL,
+    DISP_MEDIUM,
+    DISP_LARGE,
+} disp_size_t;
+
+
+
+/**********************
+ *  STATIC VARIABLES
+ **********************/
+static disp_size_t disp_size;
+
+static lv_obj_t * tv;
+static lv_obj_t * calendar;
+static lv_style_t style_text_muted;
+static lv_style_t style_title;
+static lv_style_t style_icon;
+static lv_style_t style_bullet;
+
+
+
+static const lv_font_t * font_large;
+static const lv_font_t * font_normal;
+
+static uint32_t session_desktop = 1000;
+static uint32_t session_tablet = 1000;
+static uint32_t session_mobile = 1000;
+
+/**********************
+ *      MACROS
+ **********************/
+
+/**********************
+ *   GLOBAL FUNCTIONS
+ **********************/
+
+void lv_demo_widgets(void)
+{
+    if(LV_HOR_RES <= 320) disp_size = DISP_SMALL;
+    else if(LV_HOR_RES < 720) disp_size = DISP_MEDIUM;
+    else disp_size = DISP_LARGE;
+
+    font_large = LV_FONT_DEFAULT;
+    font_normal = LV_FONT_DEFAULT;
+
+    lv_coord_t tab_h;
+    if(disp_size == DISP_LARGE) {
+        tab_h = 70;
+
+        font_large     = &lv_font_montserrat_24;
+
+
+        font_normal    = &lv_font_montserrat_16;
+
+    }
+    else if(disp_size == DISP_MEDIUM) {
+        tab_h = 45;
+
+        LV_LOG_WARN("LV_FONT_MONTSERRAT_20 is not enabled for the widgets demo. Using LV_FONT_DEFAULT instead.");
+        font_normal    = &lv_font_montserrat_14;
+
+    }
+    else {   /* disp_size == DISP_SMALL */
+        tab_h = 45;
+
+        font_large     = &lv_font_montserrat_18;
+        font_normal    = &lv_font_montserrat_12;
+
+    }
+
+#if LV_USE_THEME_DEFAULT
+    lv_theme_default_init(NULL, lv_palette_main(LV_PALETTE_BLUE), lv_palette_main(LV_PALETTE_RED), LV_THEME_DEFAULT_DARK,
+                          font_normal);
+#endif
+
+    lv_style_init(&style_text_muted);
+    lv_style_set_text_opa(&style_text_muted, LV_OPA_50);
+
+    lv_style_init(&style_title);
+    lv_style_set_text_font(&style_title, font_large);
+
+    lv_style_init(&style_icon);
+    lv_style_set_text_color(&style_icon, lv_theme_get_color_primary(NULL));
+    lv_style_set_text_font(&style_icon, font_large);
+
+    lv_style_init(&style_bullet);
+    lv_style_set_border_width(&style_bullet, 0);
+    lv_style_set_radius(&style_bullet, LV_RADIUS_CIRCLE);
+
+    /*Create an array for the points of the line*/
+        static lv_point_t line_points[] = { {5, 5}, {70, 70}, {120, 10}, {180, 60}, {240, 10} };
+
+        /*Create style*/
+        static lv_style_t style_line;
+        lv_style_init(&style_line);
+        lv_style_set_line_width(&style_line, LV_STATE_DEFAULT, 8);
+        lv_style_set_line_color(&style_line, LV_STATE_DEFAULT, LV_COLOR_BLUE);
+        lv_style_set_line_rounded(&style_line, LV_STATE_DEFAULT, true);
+
+        /*Create a line and apply the new style*/
+        lv_obj_t * line1;
+        line1 = lv_line_create(lv_scr_act());
+        lv_line_set_points(line1, line_points, 5);     /*Set the points*/
+        lv_obj_add_style(line1, LV_LINE_PART_MAIN, &style_line);     /*Set the points*/
+        lv_obj_align(line1, LV_ALIGN_CENTER, 0, 0);
+
+
+}
+
+
